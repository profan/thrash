{

  open Ast

}

%token <int> INT
%token <bool> BOOL
%token <string> VAR
%token LPAREN RPAREN 
%token LBRACKET RBRACKET
%token PLUS MINUS TIMES DIV
%token IF DO ELSE END WHILE FOR LET IN
%token BREAK CONTINUE
%token AND OR
%token EQ LT GT
%token COMMA SEMICOLON
%token EOF EOL

%relation pi<pt<pp

%start main

%%

main : expr * EOF { $1 }

expr :

  | VAR<x>                                            { Var(x) }                pi
  | INT<x>                                            { Value(Int(x)) }         pi
  | BOOL<x>                                           { Value(Bool(x)) }        pi
  | MINUS expr(=pi)<x>                                { UnaryOp("-", x) }       pi
  | LPAREN expr<x> RPAREN                             { x }                     pi

  | expr(<=pp)<x> PLUS expr(<pp)<y>                   { BinOp("+", x, y) }      pp
  | expr(<=pp)<x> MINUS expr(<pp)<y>                  { BinOp("-", x, y) }      pp
  | expr(<=pt)<x> TIMES expr(<pt)<y>                  { BinOp("*", x, y) }      pt
  | expr(<=pt)<x> DIV expr(<pt)<y>                    { BinOp("/", x, y) }      pt
  | expr(<=pt)<x> LT expr(<pt)<y>                     { BinOp("<", x, y) }      pi
  | expr(<=pt)<x> GT expr(<pt)<y>                     { BinOp(">", x, y) }      pi
  | expr(<=pt)<x> EQ expr(<pt)<y>                     { BinOp("=", x, y) }      pi
  | expr(<=pt)<x> AND expr(<pt)<y>                    { BinOp("and", x, y) }    pi
  | expr(<=pt)<x> OR expr(<pt)<y>                     { BinOp("or", x, y) }     pi

  | IF expr<cond> DO expr<thn> ELSE expr<els> END     { If(cond, thn, els) }    pi
  | WHILE expr<cond> DO expr<body> END                { While(cond, body) }     pi
  | FOR expr<cond> IN expr<list> DO expr<body> END    { For(cond, list, body) } pi
  | LBRACKET expr [COMMA expr {$2}]* RBRACKET         { List($2::$3) }          pi
  | LET VAR<var> EQ expr<e>                           { Let(var, e) }           pi
