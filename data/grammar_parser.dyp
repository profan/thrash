{

  open Ast

}

%token <int> INT
%token <bool> BOOL
%token <string> VAR
%token LPAREN RPAREN 
%token LBRACKET RBRACKET
%token PLUS MINUS TIMES DIV
%token IF DO ELSE END WHILE FOR LET IN
%token EQ LT GT
%token COMMA SEMICOLON
%token EOF EOL

%relation pi<pt<pp

%start main

%%

main : expr * EOF { $1 }

expr :

  | INT<x>                                            { Int(x) }                  pi
  | VAR<x>                                            { Var(x) }                  pi
  | MINUS expr(=pi)<x>                                { Neg(x) }                  pi
  | LPAREN expr<x> RPAREN                             { eval' x }                 pi

  | expr(<=pp)<x> PLUS expr(<pp)<y>                   { BinOp(PLUS, x, y) }       pp
  | expr(<=pp)<x> MINUS expr(<pp)<y>                  { BinOp(MINUS, x, y) }      pp
  | expr(<=pt)<x> TIMES expr(<pt)<y>                  { BinOp(TIMES, x, y) }      pt
  | expr(<=pt)<x> DIV expr(<pt)<y>                    { BinOp(DIV, x, y) }        pt
  | expr(<=pt)<x> LT expr(<pt)<y>                     { BinOp(LT, x, y) }         pt
  | expr(<=pt)<x> GT expr(<pt)<y>                     { BinOp(GT, x, y) }         pt
  | expr(<=pt)<x> EQ expr(<pt)<y>                     { BinOp(EQ, x, y) }         pt

  | IF expr<cond> DO expr<thn> ELSE expr<els> END     { thn }                     pi
  | WHILE expr<cond> DO expr<body> END                { body }                    pi
  | FOR expr<cond> IN expr<list> DO expr<body> END    { body }                    pi
  | LBRACKET expr [COMMA expr {$2}]* RBRACKET         { 0 }                       pi
  | LET VAR EQ expr<e>                                { e }                       pi

