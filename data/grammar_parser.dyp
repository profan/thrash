{

  open Ast

}

%token <int> INT
%token <bool> BOOL
%token <string> VAR
%token LPAREN RPAREN 
%token LBRACKET RBRACKET
%token PLUS MINUS TIMES DIV
%token IF DO ELSE END WHILE FOR LET IN
%token EQ LT GT
%token COMMA SEMICOLON
%token EOF EOL

%relation pi<pt<pp

%start main

%%

main : expr * EOF { $1 }

expr :

  | INT<x>                                            { Int(x) }                  pi
  | VAR<x>                                            { Var(x) }                  pi
  | BOOL<x>                                           { Bool(x) }                 pi
  | MINUS expr(=pi)<x>                                { UnaryOp(MINUS, x) }       pi
  | LPAREN expr<x> RPAREN                             { x }                       pi

  | expr(<=pp)<x> PLUS expr(<pp)<y>                   { BinOp(PLUS, x, y) }       pp
  | expr(<=pp)<x> MINUS expr(<pp)<y>                  { BinOp(MINUS, x, y) }      pp
  | expr(<=pt)<x> TIMES expr(<pt)<y>                  { BinOp(TIMES, x, y) }      pt
  | expr(<=pt)<x> DIV expr(<pt)<y>                    { BinOp(DIV, x, y) }        pt
  | expr(<=pt)<x> LT expr(<pt)<y>                     { BinOp(LT, x, y) }         pt
  | expr(<=pt)<x> GT expr(<pt)<y>                     { BinOp(GT, x, y) }         pt
  | expr(<=pt)<x> EQ expr(<pt)<y>                     { BinOp(EQ, x, y) }         pt

  | IF expr<cond> DO expr<thn> ELSE expr<els> END     { If(cond, thn, els) }      pi
  | WHILE expr<cond> DO expr<body> END                { While(cond, body) }       pi
  | FOR expr<cond> IN expr<list> DO expr<body> END    { For(cond, list, body) }   pi
  | LBRACKET expr [COMMA expr {$2}]* RBRACKET         { List($2::$3) }            pi
  | LET VAR<var> EQ expr<e>                           { Let(var, e) }             pi
